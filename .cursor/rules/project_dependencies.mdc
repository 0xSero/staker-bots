---
description: 
globs: 
alwaysApply: false
---
# Project Dependencies

## Core Dependencies

These are the primary dependencies used across both Obol and Arbitrum implementations:

### Blockchain Interaction
- **viem** (v2.x): Primary library for type-safe Ethereum interactions
  - Used for contract calls, transaction submission, and event monitoring
  - Preferred over ethers.js for new development
  - Features strong TypeScript support and better performance

### Database
- **@supabase/supabase-js**: Cloud database client for persistent storage
  - Used for storing deposit data, reward history, and execution queue
  - Provides typed interfaces for database operations

### Environment and Configuration
- **dotenv**: For loading environment variables from `.env` files
  - Used to manage sensitive configuration (private keys, API keys)

### Utility Libraries
- **lodash**: Provides utility functions for array and object manipulation
  - Used for grouping, filtering, and sorting operations

### Type Safety
- **typescript**: For type safety across the codebase
  - Provides interfaces, type definitions, and compile-time checking

### UUID Generation
- **uuid**: For generating unique identifiers
  - Used for queue item IDs and transaction tracking

### Runtime
- **tsx**: TypeScript execution environment for running TypeScript directly
  - Used instead of ts-node as per project standards
  - Used for development, testing, and scripts

## Optional Dependencies 

### OpenZeppelin Integration (for Defender Relayer Execution Strategy)
- **@openzeppelin/defender-relay-client**: For using OpenZeppelin Defender relayers
  - Optional alternative transaction execution method
  - Used when `EXECUTOR_TYPE=defender` is selected

### Testing
- **vitest**: Modern test framework for testing TypeScript code
  - Used for unit and integration tests
  - Features fast execution and good TypeScript support

### Price Feed Integration
- **axios**: HTTP client for API requests to price feeds
  - Used by price feed implementations to fetch token prices

## Package Versions

The root `package.json` should include:

```json
{
  "private": true,
  "workspaces": [
    "obol",
    "arbitrum"
  ],
  "devDependencies": {
    "typescript": "^5.x"
  }
}
```

Each implementation's `package.json` should include:

```json
{
  "dependencies": {
    "@supabase/supabase-js": "^2.x",
    "axios": "^1.x",
    "dotenv": "^16.x",
    "lodash": "^4.x",
    "uuid": "^9.x",
    "viem": "^2.x"
  },
  "devDependencies": {
    "@types/lodash": "^4.x",
    "@types/node": "^18.x",
    "@types/uuid": "^9.x",
    "tsx": "^4.x",
    "typescript": "^5.x",
    "vitest": "^1.x"
  },
  "optionalDependencies": {
    "@openzeppelin/defender-relay-client": "^1.x"
  }
}
```

## Implementation-Specific Dependencies

When refactoring the Arbitrum implementation, ensure these dependency patterns:

1. **Use viem instead of ethers.js** where possible
   - Migrate existing ethers.js code to viem for consistency
   - Use viem's public client and wallet client for blockchain interaction

2. **Use the same utility libraries** as the Obol implementation
   - Ensure consistent use of lodash, uuid, etc.
   - Remove any redundant utility libraries

3. **Align testing frameworks**
   - Use the same testing approach and libraries as Obol
   - Ensure consistent testing patterns

## Scripts Standardization

Both implementations should have these standard scripts in `package.json`:

```json
{
  "scripts": {
    "build": "tsc",
    "dev": "tsx src/index.ts",
    "prod": "node dist/index.js",
    "test": "vitest run",
    "test:watch": "vitest",
    "health-check": "tsx scripts/health-check.ts",
    "check-balance": "tsx scripts/check-balance.ts",
    "clean": "rm -rf dist",
    "lint": "eslint . --ext .ts"
  }
}
```

## Environment Variables

Both implementations should support these environment variables:

```
# Network Configuration
RPC_URL=                     # Ethereum/Arbitrum RPC endpoint URL
CHAIN_ID=                    # Chain ID (1 for Ethereum, 42161 for Arbitrum)
NETWORK_NAME=                # Network name (mainnet, arbitrum, etc.)
START_BLOCK=                 # Starting block number (optional)

# Contract Configuration
STAKER_CONTRACT_ADDRESS=     # Address of the Staker contract
LST_ADDRESS=                 # Address of the LST token
GOVLST_ADDRESSES=            # Comma-separated list of GovLst addresses

# Database Configuration
DATABASE_TYPE=               # Database type (supabase or json)
SUPABASE_URL=                # Supabase project URL (if using Supabase)
SUPABASE_KEY=                # Supabase API key (if using Supabase)

# Component Selection
COMPONENTS=                  # Comma-separated list of components to run

# Executor Configuration
EXECUTOR_TYPE=               # Executor type (wallet or defender)
EXECUTOR_PRIVATE_KEY=        # Private key (if using wallet)
DEFENDER_API_KEY=            # Defender API key (if using defender)
DEFENDER_SECRET_KEY=         # Defender secret key (if using defender)
PUBLIC_ADDRESS_DEFENDER=     # Public address of the Defender relayer

# Performance Configuration
POLL_INTERVAL=               # Polling interval in seconds
MAX_BLOCK_RANGE=             # Maximum block range for queries
CONFIRMATIONS=               # Number of confirmations to wait
GOVLST_MAX_BATCH_SIZE=       # Maximum batch size for GovLst claims
GOVLST_MIN_PROFIT_MARGIN=    # Minimum profit margin for GovLst claims
```

## Integration Patterns

When using these dependencies, follow these patterns:

### Viem Integration

```typescript
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

function createClient({ rpcUrl }: { rpcUrl: string }) {
  return createPublicClient({
    chain: mainnet,
    transport: http(rpcUrl)
  })
}

async function getBlockNumber({ client }: { client: PublicClient }): Promise<bigint> {
  return client.getBlockNumber()
}
```

### Supabase Integration

```typescript
import { createClient } from '@supabase/supabase-js'

function createSupabaseClient({ 
  url, 
  key 
}: { 
  url: string
  key: string
}) {
  return createClient(url, key)
}

async function getDeposits({ 
  client,
  owner 
}: { 
  client: SupabaseClient
  owner?: string
}) {
  const query = client.from('deposits').select('*')
  
  if (owner) {
    query.eq('owner_address', owner)
  }
  
  const { data, error } = await query
  
  if (error) {
    throw new Error(`Failed to get deposits: ${error.message}`)
  }
  
  return data
}
```

### TSX Usage

Always use TSX instead of ts-node for running TypeScript files directly:

```bash
# Correct
npx tsx src/index.ts

# Incorrect - Do not use
npx ts-node src/index.ts
```

## Contract Dependencies

The system will interact with the following contracts:

1. **GovLst Contract**
   - Contains the `claimAndDistributeReward` function we'll be calling
   - Manages the liquid staking token functionality
   - Source: [GovLst.sol](mdc:https:/github.com/withtally/stGOV/blob/main/src/GovLst.sol)

2. **Staker Contract**
   - Referenced by GovLst for staking operations
   - Contains stake deposit information and unclaimed rewards
   - Used to identify deposits owned by GovLst contracts

## Infrastructure Dependencies

1. **RPC Provider**
   - Ethereum RPC endpoint for blockchain interactions
   - Should support archive node capabilities for historical data
   - Example providers: Infura, Alchemy, or self-hosted node

2. **Supabase Project**
   - PostgreSQL database for persistent storage
   - Used by the `DatabaseWrapper` for all storage operations

3. **CoinMarketCap API** (or equivalent)
   - Used for token price information
   - Required for profitability calculations

## Environment Variables

The system requires the following environment variables:

```
# Blockchain Connection
RPC_URL=                     # Ethereum RPC endpoint URL
CHAIN_ID=42161               # Chain ID (default for Arbitrum One)

# Contract Addresses
STAKER_CONTRACT_ADDRESS=     # Address of the Staker contract
GOVLST_ADDRESSES=            # Comma-separated list of GovLst addresses to monitor

# GovLst Configuration
MIN_PROFIT_MARGIN=           # Minimum profit margin in wei
MAX_BATCH_SIZE=              # Maximum number of deposits in a batch
CLAIM_INTERVAL=              # Interval in seconds between claim checks

# Database Configuration
SUPABASE_URL=                # Supabase project URL
SUPABASE_KEY=                # Supabase API key

# Execution Configuration
PRIVATE_KEY=                 # Private key for transaction execution (if using wallet)
TIP_RECEIVER=                # Address to receive tips

# Optional Relayer Configuration
DEFENDER_API_KEY=            # OpenZeppelin Defender API key (if using relayer)
DEFENDER_API_SECRET=         # OpenZeppelin Defender API secret (if using relayer)

# Price Feed Configuration
COINMARKETCAP_API_KEY=       # CoinMarketCap API key for price data
```

## Internal Dependencies

The GovLst Rewards Claimer component depends on the following internal components:

1. **Monitor Component**
   - For detecting deposit creation and updates

2. **Profitability Engine**
   - For determining when to execute claim transactions
   - Will be modified to work with reward claims

3. **Executor Component**
   - For submitting transactions to the blockchain

4. **Database Component**
   - For storing deposit and reward information

5. **Shared Utilities**
   - For price feeds, logging, and configuration