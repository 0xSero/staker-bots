---
description: 
globs: 
alwaysApply: true
---
# Staker-Bots Coding Style Guide

## Core Programming Principles

1. **Functional Programming Approach**
   - Use functional, declarative programming patterns
   - Avoid classes and object-oriented patterns when possible
   - Use the `function` keyword for pure functions
   - Prefer iteration and modularization over duplication

2. **RORO Pattern (Receive an Object, Return an Object)**
   - Accept parameters as objects for flexibility and readability
   - Return structured objects from functions
   - Use destructuring for clear parameter handling

3. **TypeScript First**
   - Use TypeScript for all code
   - Prefer interfaces over types
   - Avoid enums, use mapped types or const objects instead
   - Use explicit typing for function parameters and returns

4. **Error Handling and Validation**
   - Handle errors and edge cases at the beginning of functions
   - Use early returns for error conditions to avoid nested logic
   - Place the happy path last in the function
   - Avoid unnecessary else statements; use if-return pattern
   - Use guard clauses to handle preconditions early
   - Implement proper error logging with contextual information

## File and Directory Structure

1. **Naming Conventions**
   - Use lowercase with dashes for directories (e.g., `price-feeds`)
   - Use PascalCase for component files
   - Use camelCase for utility and non-component files
   - Use descriptive names with auxiliary verbs (e.g., `isLoading`, `hasPermission`)

2. **File Organization**
   - Favor named exports for components and functions
   - File structure:
     1. Exported components/functions
     2. Helper functions
     3. Static content variables
     4. Type definitions
   - Keep files focused on a single responsibility

3. **Directory Structure**
   - Organize by component/feature rather than by type
   - Keep related functionality together
   - Place interfaces in dedicated `interfaces/` directories
   - Place implementation strategies in `strategies/` directories

## Coding Style

```typescript
// Proper function declaration with RORO pattern
function processDeposit({ 
  deposit, 
  gasPrice, 
  options = {} 
}: { 
  deposit: Deposit
  gasPrice: bigint
  options?: ProcessOptions 
}): ProcessResult {
  // Error handling first
  if (!deposit.id) return { success: false, error: "Invalid deposit" }
  
  // Processing logic
  const result = calculateProfitability({
    amount: deposit.amount,
    gasPrice,
    tokenPrice: options.tokenPrice
  })
  
  // Return structured result
  return {
    success: true,
    profit: result.profit,
    isWorthClaiming: result.profit > 0
  }
}

// Simple conditional statements
if (condition) doSomething()

// Early returns
function validateInput({ data }: { data: unknown }): ValidationResult {
  if (!data) return { valid: false, error: "Data is required" }
  if (typeof data !== "object") return { valid: false, error: "Data must be an object" }
  
  // Continue with validation
  return { valid: true }
}
```

## State Management and Component Design

1. **Component Structure**
   - Use functional components only
   - Keep components small and focused
   - Separate UI logic from business logic

2. **State Management**
   - Minimize state use when possible
   - Use appropriate state management based on complexity:
     - Local state for simple UI state
     - Context for shared state when needed
     - External state management libraries sparingly

3. **Side Effects**
   - Keep side effects isolated and minimal
   - Clearly document side effects
   - Use consistent patterns for side effect management

## Code Quality and Testing

1. **Testing Strategy**
   - Focus on integration tests over unit tests where appropriate
   - Test with real functions (no mocking)
   - Test error cases thoroughly
   - Ensure tests follow the project's coding standards

2. **Code Documentation**
   - Use JSDoc for public APIs and complex functions
   - Keep comments focused on why, not what
   - Use descriptive variable and function names to make code self-documenting

3. **Error Handling**
   - Categorize errors appropriately (user errors vs. system errors)
   - Provide contextual information in error messages
   - Log errors at appropriate levels

## Examples of Good Code

### Function with RORO Pattern

```typescript
function calculateProfitability({ 
  rewardAmount, 
  gasPrice, 
  tokenPrice, 
  ethPrice 
}: { 
  rewardAmount: bigint
  gasPrice: bigint
  tokenPrice: number
  ethPrice: number
}): { 
  profit: bigint
  gasCost: bigint
  isWorthClaiming: boolean 
} {
  if (rewardAmount === 0n) {
    return { profit: 0n, gasCost: 0n, isWorthClaiming: false }
  }

  const gasCost = calculateGasCost({ gasPrice, gasLimit: 300000n })
  const gasCostInToken = convertGasCostToToken({ gasCost, ethPrice, tokenPrice })
  const profit = rewardAmount - gasCostInToken

  return {
    profit,
    gasCost,
    isWorthClaiming: profit > 0n
  }
}
```

### Error Handling Pattern

```typescript
function processTransaction({ 
  tx, 
  options 
}: { 
  tx: Transaction
  options?: ProcessOptions
}): Promise<TransactionResult> {
  // Validation first
  if (!tx.hash) {
    return Promise.resolve({ 
      success: false, 
      error: "Transaction hash is required" 
    })
  }

  // Early return for specific conditions
  if (tx.status === "completed") {
    return Promise.resolve({ 
      success: true, 
      status: "already_processed" 
    })
  }

  try {
    // Happy path last
    const result = await submitTransaction({ tx, options })
    return { success: true, result }
  } catch (error) {
    logger.error("Failed to process transaction", { 
      error: error.message, 
      txHash: tx.hash 
    })
    return { 
      success: false, 
      error: error.message, 
      code: getErrorCode(error) 
    }
  }
}
```

## Anti-Patterns to Avoid

1. ❌ **Class-based components**
   ```typescript
   // Avoid this
   class ProfitabilityEngine {
     constructor() {
       this.state = {}
     }
     
     calculate() {
       // Implementation
     }
   }
   ```

2. ❌ **Deeply nested conditionals**
   ```typescript
   // Avoid this
   if (condition1) {
     if (condition2) {
       if (condition3) {
         // Implementation
       }
     }
   }
   ```

3. ❌ **Function with many parameters**
   ```typescript
   // Avoid this
   function calculate(amount, price, gas, limit, threshold, tokens, time) {
     // Implementation
   }
   ```

4. ❌ **Unclear error handling**
   ```typescript
   // Avoid this
   try {
     const result = doSomething()
     return result
   } catch (e) {
     console.error(e)
     return null
   }
   ```

5. ❌ **Mixing business logic with UI**
   ```typescript
   // Avoid this in React components
   function Component() {
     // Complex business logic here
     const profit = calculateComplexProfitability(data)
     return <div>{profit}</div>
   }
   ```
